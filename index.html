<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Generador de Equipos</title>

<!-- ICONO Y COLOR DE LA WEB APP -->
<link rel="icon" href="icono.png" type="image/png">
<link rel="apple-touch-icon" href="icono.png">
<meta name="theme-color" content="#0f1724">
<link rel="manifest" href="manifest.json">

<style>
/* ----------------- TIPOGRAF√çA Y FONDO ----------------- */
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

:root{ --bg1:#0f1724; --bg2:#1a2238; --accent:#06b6d4; --card-bg: rgba(255,255,255,0.05); --text:#e6eef6; }

body{
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
  color: var(--text);
  padding: 10px;
  text-align: center;
  margin: 0;
  min-height: 100vh;
  animation: fadeIn 0.8s ease-in-out;
}

/* Animaciones reutilizables */
@keyframes fadeIn{ from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:none;} }
@keyframes slideDown{ from{transform:translateY(-20px);opacity:0;} to{transform:none;opacity:1;} }
@keyframes fadeInUp{ from{opacity:0; transform:translateY(6px);} to{opacity:1; transform:none;} }

/* ----------------- ENCABEZADO ----------------- */
h1{
  margin-bottom:10px;
  font-weight:600;
  color:#0ff0fc;
  letter-spacing:0.5px;
  text-shadow:0 0 8px rgba(0,255,255,0.4);
  animation: slideDown 0.8s ease;
}

/* ----------------- TARJETAS / COMPONENTES ----------------- */
.card{
  background: var(--card-bg);
  backdrop-filter: blur(8px);
  padding: 14px;
  border-radius: 12px;
  margin: 10px auto;
  width: 95%;
  max-width: 600px;
  text-align: left;
  box-shadow: 0 0 12px rgba(0,0,0,0.3);
  animation: fadeIn 1s ease;
}

/* Lista de jugadores */
.players-list { list-style:none; padding:0; max-height:200px; overflow:auto; }
.players-list li{
  padding:6px; margin:3px 0; background: rgba(255,255,255,0.08); border-radius:8px;
  display:flex; justify-content:space-between; transition: background 0.2s, transform 0.2s;
  animation: fadeInUp 0.4s ease both;
}
.players-list li:hover{ background: rgba(255,255,255,0.15); transform: translateX(4px); }

/* Botones */
button{
  background: linear-gradient(135deg,#06b6d4,#0ea5e9);
  color:#fff; cursor:pointer; margin:6px; padding:8px 14px; border-radius:8px;
  border:none; font-weight:600; font-size:14px; transition: all 0.2s ease; animation: fadeIn 0.8s ease;
}
button:hover{ transform: scale(1.05); box-shadow:0 0 10px rgba(6,182,212,0.5);}
button:active{ transform: scale(0.96); }

/* Proposals grid */
#proposalsContainer{ margin-top:12px; display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:14px; }
.proposal{
  padding:10px; background: rgba(255,255,255,0.05); border-radius:10px; cursor:pointer;
  display:flex; flex-direction:column; gap:6px; transition: transform 0.2s, background 0.2s; animation: fadeInUp 0.6s ease both;
}
.proposal:hover{ transform: translateY(-4px); background: rgba(255,255,255,0.1); }

.team-box{
  background: rgba(255,255,255,0.03); padding:6px; border-radius:8px; display:flex; flex-direction:column; gap:3px;
}
.team-title{ font-weight:600; margin-bottom:4px; color: var(--accent); }
.player-entry{ display:flex; justify-content:space-between; background: rgba(255,255,255,0.08); padding:4px 8px; border-radius:6px; font-size:13px; }

/* ----------------- CAMPOS ----------------- */
#fieldsContainer{ display:flex; justify-content:center; gap:20px; margin-top:25px; flex-wrap:wrap; animation: fadeIn 1s ease; }

.field{
  position: relative; width: 320px; height: 480px; background-color: #0f4720; border:2px solid #fff;
  border-radius:10px; display:none; box-shadow:0 0 20px rgba(0,255,100,0.15); overflow:hidden;
}
.field-title{
  position:absolute; top:6px; width:100%; text-align:center; font-weight:600; color:#fff; font-size:13px; letter-spacing:0.5px;
  text-shadow:0 0 6px rgba(0,0,0,0.5);
}

/* Player cards para html2canvas ‚Äî fondo s√≥lido para evitar transparencia */
.player-card{
  position:absolute; width:45px; height:50px; text-align:center; font-weight:600; color:#fff; cursor:grab;
  transition: transform 0.2s ease; animation: fadeInUp 0.3s ease both; background:#000; border-radius:5px; overflow:hidden;
}
.player-card img{ width:100%; height:100%; display:block; background:#000; }
.player-card span{ display:block; font-size:10px; margin-top:2px; word-wrap:break-word; background:#000; color:#fff; padding:1px 2px; border-radius:2px; }

/* Export button estilo verde */
.export-btn{ margin-top:8px; background: linear-gradient(135deg,#22c55e,#16a34a); }
.export-btn:hover{ box-shadow:0 0 10px rgba(34,197,94,0.5); }

/* Login / register estilos */
.login-card, #registerCard{ max-width:300px; margin:20px auto; padding:20px; background:var(--card-bg); border-radius:10px; text-align:center; box-shadow:0 0 12px rgba(0,0,0,0.3); }
.login-input, #registerCard input{ width:90%; margin:6px 0; padding:8px; border-radius:8px; border:none; background: rgba(255,255,255,0.1); color:#e6eef6; font-size:14px; }
.login-input::placeholder, #registerCard input::placeholder{ color:#b8c2cc; }

/* Mobile PWA display-mode adjustments */
@media (display-mode: standalone){
  body{ padding:0; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; overflow:hidden; }
  h1{ margin-top:20px; font-size:22px; }
  .card{ width:90%; margin-top:10px; }
  button{ font-size:16px; padding:12px 18px; border-radius:10px; }
  #fieldsContainer{ transform: scale(0.9); }
}

/* --- Mejora de nitidez en exportaci√≥n (forzar comportamiento) --- */
.player-card, .player-card img, .player-card span{ opacity:1 !important; filter:none !important; transform:none !important; mix-blend-mode:normal !important; will-change:auto !important; isolation:isolate !important; }
#field1, #field2{ background-color:#0f4720 !important; opacity:1 !important; mix-blend-mode:normal !important; transform:none !important; will-change:auto !important; isolation:isolate !important; }

/* --- Campo (l√≠neas internas / √°reas) visuales internas (si se necesitan) --- */
.player{ position:absolute; text-align:center; color:white; font-size:12px; user-select:none; }
.shirt{ border-radius:50%; width:28px; height:28px; line-height:28px; font-weight:bold; margin:auto; box-shadow:0 0 4px rgba(0,0,0,0.4); }
.shirt.black{ background:black; color:white; }
.shirt.white{ background:white; color:black; }
.player-name{ font-size:10px; color:white; text-shadow:0 0 3px black; }

</style>
</head>
<body>

<h1>GENERADOR DE EQUIPOS Y ALINEACIONES</h1>

<!-- LOGIN -->
<div class="login-card" id="loginCard">
  <strong>Identif√≠cate</strong><br>
  <input type="text" id="loginUser" placeholder="Usuario" class="login-input"><br>
  <input type="password" id="loginPass" placeholder="Contrase√±a" class="login-input"><br>
  <button id="loginBtn">Entrar</button>
  <div id="loginMsg" style="color:red;margin-top:6px;"></div>
</div>

<!-- REGISTRO -->
<div id="registerCard">
  <strong>Reg√≠strate</strong><br>
  <input type="text" id="regUser" placeholder="Usuario"><br>
  <input type="password" id="regPass" placeholder="Contrase√±a"><br>
  <button id="registerBtn">Registrar</button>
  <div id="regMsg" style="color:red;margin-top:6px;"></div>
</div>

<!-- JUGADORES -->
<div class="card" id="playersCard" style="display:none;">
  <strong>Selecciona los jugadores que van a jugar (m√°x. 14):</strong>
  <ul id="playersContainer" class="players-list"></ul>
  <button id="generate">Generar hasta 5 combinaciones</button>
  <button id="generateOptimized">Optimizar equilibrio</button>
</div>

<div class="card" id="addPlayerCard" style="display:none;">
  <strong>Agregar jugador:</strong><br>
  <input type="text" id="newName" placeholder="Nombre" class="login-input"><br>
  <select id="newPos" class="login-input">
    <option value="Portero">Portero</option>
    <option value="Defensa">Defensa</option>
    <option value="Delantero">Delantero</option>
    <option value="Mediocentro">Mediocentro</option>
  </select><br>
  <input type="number" id="newMedia" placeholder="Media (0-10)" class="login-input" min="0" max="10"><br>
  <button id="addPlayerBtn">Agregar jugador</button>
</div>

<!-- PROPUESTAS -->
<div class="card" id="proposalsCard" style="display:none;">
  <strong>Propuestas generadas (haz click en la que prefieras):</strong>
  <div id="proposalsContainer"></div>
</div>

<!-- CAMPOS -->
<div id="fieldsContainer">
  <div>
    <div id="field1" class="field"><div class="field-title">Equipo Negro</div></div>
    <button class="export-btn" onclick="exportField('field1')">Exportar Equipo Negro</button>
  </div>
  <div>
    <div id="field2" class="field"><div class="field-title">Equipo Blanco</div></div>
    <button class="export-btn" onclick="exportField('field2')">Exportar Equipo Blanco</button>
  </div>
</div>

<!-- NUEVO BOT√ìN GLOBAL -->
<div style="text-align:center; margin-top:20px;">
  <button id="exportarAmbosBtn" class="export-btn">üì∏ Exportar Ambos Equipos</button>
</div>

<!-- html2canvas (misma versi√≥n que ten√≠as) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
/* =========================
   VARIABLES GLOBALES / CONFIG
   ========================= */

/* URL a tu backend (igual que ten√≠as) */
const API_URL = 'https://futbol-backend-0gnv.onrender.com';

/* Orden de posiciones para mostrar en la lista */
const positionOrder = { Portero: 0, Defensa: 1, Delantero: 2, Mediocentro: 3 };

/* Im√°genes de camisetas (las rutas que usas) */
const shirtImages = { black: "camiseta-negra.png", white: "camiseta-blanca.png" };

/* Estado global que us√°bamos */
let currentUser = null;
let currentPlayers = [];
let currentProposals = [];
let teamAlertShown = false; // evita m√∫ltiples alertas repetidas

/* =========================
   LOGIN / REGISTRO
   ========================= */

/* Login: POST /login, luego cargar jugadores con POST /get-players */
document.getElementById('loginBtn').addEventListener('click', async () => {
  const username = document.getElementById('loginUser').value.trim();
  const password = document.getElementById('loginPass').value.trim();
  const loginMsg = document.getElementById('loginMsg'); 
  loginMsg.textContent = '';

  if (!username || !password) {
    loginMsg.textContent = 'Introduce usuario y contrase√±a';
    return;
  }

  try {
    const res = await fetch(`${API_URL}/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });
    const data = await res.json();

    if (!data.success) {
      loginMsg.textContent = data.message || 'Credenciales incorrectas';
      return;
    }

    currentUser = { username };

    // Intentar cargar jugadores desde backend; si falla inicializamos array vac√≠o
    try {
      const resPlayers = await fetch(`${API_URL}/get-players`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username })
      });
      const playersResp = await resPlayers.json();
      currentPlayers = Array.isArray(playersResp.players) ? playersResp.players : [];
    } catch (err) {
      console.warn('No se pudieron cargar los jugadores del servidor, inicializando vac√≠o', err);
      currentPlayers = [];
    }

    // Mostrar UI principal
    document.getElementById('loginCard').style.display = 'none';
    document.getElementById('registerCard').style.display = 'none';
    document.getElementById('playersCard').style.display = 'block';
    document.getElementById('addPlayerCard').style.display = 'block';
    renderPlayerList();

  } catch (err) {
    console.error(err);
    loginMsg.textContent = 'Error de conexi√≥n';
  }
});

/* Registro: POST /register */
document.getElementById('registerBtn').addEventListener('click', async ()=> {
  const username = document.getElementById('regUser').value.trim();
  const password = document.getElementById('regPass').value.trim();
  const regMsg = document.getElementById('regMsg');
  regMsg.textContent = '';

  if (!username || !password) { regMsg.textContent = 'Introduce usuario y contrase√±a'; return; }

  try{
    const res = await fetch(`${API_URL}/register`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ username, password })
    });
    const data = await res.json();
    regMsg.textContent = data.message || '';
    if (data.success) {
      document.getElementById('regUser').value = '';
      document.getElementById('regPass').value = '';
    }
  } catch (err) {
    console.error(err);
    regMsg.textContent = 'Error de conexi√≥n';
  }
});

/* =========================
   RENDER LISTA DE JUGADORES
   ========================= */

/* Renderiza la lista local de jugadores con checkbox y bot√≥n eliminar */
function renderPlayerList() {
  // Ordenamos por posici√≥n seg√∫n positionOrder pero mantenemos index original
  const mapped = currentPlayers.map((p, idx) => ({ p, idx }));
  mapped.sort((a,b) => (positionOrder[a.p.pos] ?? 99) - (positionOrder[b.p.pos] ?? 99));

  const container = document.getElementById('playersContainer');
  container.innerHTML = '';

  mapped.forEach(({ p, idx }) => {
    const li = document.createElement('li');
    li.innerHTML = `
      <label style="flex:1;">
        <input type="checkbox" data-index="${idx}">
        ${p.name} (${p.pos}) [${p.media}]
      </label>
      <button class="delete-btn" data-index="${idx}" style="margin-left:8px; background-color:#e74c3c; color:white; border:none; border-radius:5px; padding:4px 8px; cursor:pointer;">
        Eliminar
      </button>
    `;
    container.appendChild(li);
  });

  // Limitar selecci√≥n a 14 checkboxes marcados
  const checkboxes = container.querySelectorAll('input[type="checkbox"]');
  checkboxes.forEach(cb => {
    cb.addEventListener('change', () => {
      const checked = container.querySelectorAll('input[type="checkbox"]:checked');
      if (checked.length > 14) {
        cb.checked = false;
        alert('No se pueden seleccionar m√°s de 14 jugadores');
      }
    });
  });

  // Asociar evento de eliminar a cada bot√≥n
  container.querySelectorAll('.delete-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const idx = Number(btn.dataset.index);
      const player = currentPlayers[idx];
      if (!player) return;
      if (!confirm(`¬øSeguro que quieres eliminar a ${player.name}?`)) return;

      try {
        const res = await fetch(`${API_URL}/delete-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: currentUser.username, playerName: player.name })
        });
        const data = await res.json();
        if (!data.success) { alert(data.message || 'Error al eliminar jugador'); return; }

        // Eliminar localmente y re-renderizar
        currentPlayers.splice(idx, 1);
        renderPlayerList();
      } catch (err) {
        console.error('Error al eliminar jugador:', err);
        alert('Error de conexi√≥n al eliminar jugador');
      }
    });
  });
}

/* =========================
   AGREGAR JUGADOR
   ========================= */
document.getElementById('addPlayerBtn').addEventListener('click', async ()=> {
  const name = document.getElementById('newName').value.trim();
  const pos = document.getElementById('newPos').value;
  const media = parseFloat(document.getElementById('newMedia').value);
  if (!name || isNaN(media) || media < 0 || media > 10) { alert('Datos incorrectos'); return; }

  const newPlayer = { name, pos, media };
  try {
    const res = await fetch(`${API_URL}/add-player`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ username: currentUser.username, player: newPlayer })
    });
    const data = await res.json();
    if (!data.success) { alert(data.message || 'Error al guardar jugador'); return; }
    currentPlayers.push(newPlayer);
    renderPlayerList();
    document.getElementById('newName').value = '';
    document.getElementById('newMedia').value = '';
  } catch (err) {
    console.error(err);
    alert('Error al guardar jugador');
  }
});

/* =========================
   FUNCIONES PARA GENERAR EQUIPOS
   ========================= */

/* Mezcla Fisher-Yates (in-place) */
function shuffle(a){
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* Calcula media de 'media' de jugadores en un equipo */
function averageMedia(team){
  return team.reduce((s, p) => s + (p.media || 0), 0) / (team.length || 1);
}

/* Comprueba si una propuesta ya est√° en la lista (por nombres) */
function isDuplicate(proposals, newTeams){
  const newStr = JSON.stringify(newTeams.map(t => t.map(p => p.name).sort()));
  return proposals.some(p => JSON.stringify(p.map(t => t.map(p2 => p2.name).sort())) === newStr);
}

/* Genera dos equipos balanceados intentando respetar m√≠nimos por posici√≥n.
   Mantener la l√≥gica y l√≠mites parecidos a la versi√≥n original.
*/
function generateTeams(players, numTeams = 2) {
  const maxPlayers = 7;

  // Agrupar por posiciones conocidas
  const posGroups = { Portero: [], Defensa: [], Delantero: [], Otros: [] };
  players.forEach(p => {
    if (p.pos === 'Portero' || p.pos === 'Defensa' || p.pos === 'Delantero' || p.pos === 'Mediocentro') {
      posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos] = posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos] || [];
      posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos].push(p);
    } else {
      posGroups.Otros.push(p);
    }
  });

  // Validaci√≥n m√≠nima (igual que tu l√≥gica original)
  const minPorteros = (posGroups.Portero?.length || 0);
  const minDefensas = (posGroups.Defensa?.length || 0);
  const minDelanteros = (posGroups.Delantero?.length || 0);
  if (minPorteros < 2 || minDefensas < 6 || minDelanteros < 2) {
    if (!teamAlertShown) { alert('No hay suficientes jugadores para formar equipos completos respetando m√≠nimos por posici√≥n'); teamAlertShown = true; }
    return null;
  }

  let bestTeams = null;
  let smallestDiff = Infinity;
  const iterations = 500;

  for (let it = 0; it < iterations; it++) {
    // Copias locales
    const porteros = [...(posGroups.Portero || [])];
    const defensas = [...(posGroups.Defensa || [])];
    const delanteros = [...(posGroups.Delantero || [])];
    const mediocentros = [...(posGroups.Mediocentro || [])];
    const otros = [...(posGroups.Otros || [])];

    shuffle(porteros); shuffle(defensas); shuffle(delanteros); shuffle(mediocentros); shuffle(otros);

    let teamA = [], teamB = [];

    // Asignar porteros
    if (porteros.length >= 2) { teamA.push(porteros.shift()); teamB.push(porteros.shift()); }

    // Asignar defensas: 3 y 3
    teamA.push(...defensas.splice(0, 3));
    teamB.push(...defensas.splice(0, 3));

    // Asignar delanteros: 1 y 1
    if (delanteros.length >= 2) { teamA.push(delanteros.shift()); teamB.push(delanteros.shift()); }

    // Si hay mediocentros, repartir uno por equipo si es posible
    if (mediocentros.length > 0) {
      teamA.push(mediocentros.shift());
      if (mediocentros.length > 0) teamB.push(mediocentros.shift());
    }

    // Rellenar con los restantes (porteros/defensas/delanteros/otros) hasta maxPlayers
    const remaining = [...porteros, ...defensas, ...delanteros, ...mediocentros, ...otros];
    while (teamA.length < maxPlayers && remaining.length > 0) teamA.push(remaining.shift());
    while (teamB.length < maxPlayers && remaining.length > 0) teamB.push(remaining.shift());

    // Validar tama√±o
    if (teamA.length !== maxPlayers || teamB.length !== maxPlayers) continue;

    const diff = Math.abs(averageMedia(teamA) - averageMedia(teamB));
    if (diff < smallestDiff) {
      smallestDiff = diff;
      bestTeams = [teamA, teamB];
    }
  }

  if (!bestTeams) {
    if (!teamAlertShown) { alert('No se pudieron generar equipos completos con los jugadores seleccionados'); teamAlertShown = true; }
    return null;
  }
  return bestTeams;
}

/* =========================
   GENERAR PROPUESTAS (interfaz)
   ========================= */

function generateProposals(selected, optimized = false) {
  teamAlertShown = false;
  currentProposals = [];
  let attempts = 0;
  while (currentProposals.length < 5 && attempts < 50) {
    const teams = generateTeams(selected, 2);
    if (!teams) { attempts++; continue; }
    if (!isDuplicate(currentProposals, teams)) currentProposals.push(teams);
    attempts++;
  }
  if (currentProposals.length === 0) {
    console.warn('No se pudieron generar equipos v√°lidos con los jugadores seleccionados');
    return;
  }
  renderProposals();
}

/* Bot√≥n generar normal */
document.getElementById('generate').addEventListener('click', () => {
  const selectedIndexes = [...document.querySelectorAll('#playersContainer input:checked')].map(chk => Number(chk.dataset.index));
  if (selectedIndexes.length < 5) { alert('Selecciona al menos 5 jugadores'); return; }
  const selected = selectedIndexes.map(i => currentPlayers[i]).filter(Boolean);
  const count = { Portero:0, Defensa:0, Delantero:0 };
  selected.forEach(p => count[p.pos] = (count[p.pos]||0) + 1);
  if (count.Portero < 1 || count.Defensa < 3 || count.Delantero < 1) {
    alert('Debe haber al menos 1 portero, 3 defensas y 1 delantero seleccionados'); return;
  }
  generateProposals(selected);
});

/* Bot√≥n generar optimizado (misma interfase pero con marca 'optimized' si quisieras ampliar) */
document.getElementById('generateOptimized').addEventListener('click', () => {
  const selectedIndexes = [...document.querySelectorAll('#playersContainer input:checked')].map(chk => Number(chk.dataset.index));
  if (selectedIndexes.length < 5) { alert('Selecciona al menos 5 jugadores'); return; }
  const selected = selectedIndexes.map(i => currentPlayers[i]).filter(Boolean);
  generateProposals(selected, true);
});

/* =========================
   RENDER PROPUESTAS EN PANTALLA
   ========================= */
function renderProposals(){
  const container = document.getElementById('proposalsContainer');
  container.innerHTML = '';
  currentProposals.forEach((teams, i) => {
    const div = document.createElement('div');
    div.className = 'proposal';

    const media1 = averageMedia(teams[0]);
    const media2 = averageMedia(teams[1]);
    const diff = Math.abs(media1 - media2).toFixed(2);

    const diffDiv = document.createElement('div');
    diffDiv.textContent = `Diferencia de media: ${diff}`;
    diffDiv.style.fontSize = '12px';
    diffDiv.style.color = '#aaa';
    div.appendChild(diffDiv);

    ['Equipo Negro','Equipo Blanco'].forEach((title, idx) => {
      const teamDiv = document.createElement('div');
      teamDiv.className = 'team-box';
      const tTitle = document.createElement('div');
      tTitle.className = 'team-title';
      tTitle.textContent = title;
      teamDiv.appendChild(tTitle);

      teams[idx].forEach(p => {
        const pDiv = document.createElement('div');
        pDiv.className = 'player-entry';
        pDiv.textContent = `${p.name} (${p.pos}) [${p.media}]`;
        teamDiv.appendChild(pDiv);
      });
      div.appendChild(teamDiv);
    });

    div.addEventListener('click', () => applyTeams(teams));
    container.appendChild(div);
  });
  document.getElementById('proposalsCard').style.display = 'block';
}

/* =========================
   MOSTRAR / APLICAR EQUIPOS EN LOS CAMPOS
   ========================= */

/* Aplica los equipos seleccionados a los dos campos (muestra campos y dibuja) */
function applyTeams(teams) {
  const field1 = document.getElementById('field1');
  const field2 = document.getElementById('field2');
  field1.style.display = 'block';
  field2.style.display = 'block';

  // Limpiar contenido previo dejando el t√≠tulo
  field1.innerHTML = '<div class="field-title">Equipo Negro</div>';
  field2.innerHTML = '<div class="field-title">Equipo Blanco</div>';

  // Dibujar l√≠neas del campo (visuales internas) y jugadores
  drawField(field1);
  drawField(field2);

  // Dibujar jugadores en cada campo como player-cards (color y comportamiento igual a original)
  drawTeamOnField(field1, teams[0], 'black');
  drawTeamOnField(field2, teams[1], 'white');
}

/* Dibuja las l√≠neas y elementos b√°sicos del campo dentro del elemento field */
function drawField(field){
  // No tocar estilos principales, solo a√±adir las l√≠neas internas (mejor compatibilidad que canvas)
  // Si existen l√≠neas previas, eliminarlas
  const existing = field.querySelector('.field-lines');
  if (existing) existing.remove();

  const lines = document.createElement('div');
  lines.className = 'field-lines';
  lines.style.position = 'absolute';
  lines.style.left = '0';
  lines.style.top = '0';
  lines.style.width = '100%';
  lines.style.height = '100%';
  lines.style.pointerEvents = 'none'; // para que no interfiera con drag

  // L√≠nea central, √°reas y c√≠rculo central (usando % para adaptar a distintos tama√±os)
  lines.innerHTML = `
    <div style="position:absolute;top:50%;left:0;width:100%;height:2px;background:white;transform:translateY(-50%);"></div>
    <div style="position:absolute;top:0;left:50%;width:30%;height:20%;border:2px solid white;transform:translateX(-50%);box-sizing:border-box;"></div>
    <div style="position:absolute;bottom:0;left:50%;width:30%;height:20%;border:2px solid white;transform:translateX(-50%);box-sizing:border-box;"></div>
    <div style="position:absolute;top:50%;left:50%;width:25%;height:25%;border:2px solid white;border-radius:50%;transform:translate(-50%,-50%);box-sizing:border-box;"></div>
  `;
  field.appendChild(lines);
}

/* =========================
   DIBUJAR JUGADORES EN EL CAMPO + DRAG & SNAP
   ========================= */

/* Dibuja un equipo en el campo: crea .player-card, sit√∫a y hace draggable */
function drawTeamOnField(field, team, color) {
  // Eliminar player-cards previas
  field.querySelectorAll('.player-card').forEach(n => n.remove());

  // Posiciones base en px relative al tama√±o del field ‚Äî se adaptan autom√°ticamente cuando se calcula left/top
  const fw = field.clientWidth;
  const fh = field.clientHeight;

  // Distribuci√≥n por roles: porteros arriba/abajo o en posiciones t√≠picas dependiendo del equipo
  const positionsY = { Portero: fh * 0.85, Defensa: fh * 0.62, Mediocentro: fh * 0.45, Delantero: fh * 0.28 };

  // Separar mediocentro si existe (igual que l√≥gica original pero m√°s expl√≠cita)
  const mediocentro = team.find(p => p.pos === 'Mediocentro') || null;

  // Categor√≠as a iterar (con 'Otros' para posiciones raras)
  ['Portero','Defensa','Mediocentro','Delantero','Otros'].forEach(cat => {
    let arr;
    if (cat === 'Otros') {
      arr = team.filter(p => !['Portero','Defensa','Delantero','Mediocentro'].includes(p.pos));
    } else {
      arr = team.filter(p => p.pos === cat);
    }
    // Si hay mediocentro, evitar duplicarlo fuera de su categor√≠a
    if (mediocentro && cat !== 'Mediocentro') arr = arr.filter(p => p !== mediocentro);

    // Calcular espaciado horizontal
    const spacing = fw / (arr.length + 1);
    arr.forEach((p, i) => {
      const div = document.createElement('div');
      div.className = 'player-card';
      // Imagen de camiseta + nombre (mantener misma estructura que usabas)
      const img = document.createElement('img'); img.src = shirtImages[color]; img.alt = `${p.name}`;
      const span = document.createElement('span'); span.textContent = p.name;
      div.appendChild(img); div.appendChild(span);

      // Calcular posici√≥n: top seg√∫n rol o mediocentro, left seg√∫n espaciado
      const y = (p === mediocentro) ? positionsY.Mediocentro : (positionsY[p.pos] || positionsY.Defensa);
      const leftPx = Math.max(5, Math.round(spacing * (i + 1) - 20)); // -20 para centrar
      div.style.top = `${Math.round(y)}px`;
      div.style.left = `${leftPx}px`;

      // A√±adir al DOM del campo
      field.appendChild(div);

      // Hacer draggable con snap y reordenado horizontal al soltar
      makeDraggable(div, field, positionsY);
    });
  });
}

/* makeDraggable: permite arrastrar con rat√≥n y t√°ctil, aplica 'snap' vertical a posicionesY y reordena horizontal */
function makeDraggable(el, field, positionsY){
  let offsetX = 0, offsetY = 0;
  let dragging = false;

  // obtener bounding rect del field cada vez (responde a cambios de tama√±o)
  function startDrag(clientX, clientY){
    const rect = el.getBoundingClientRect();
    offsetX = clientX - rect.left;
    offsetY = clientY - rect.top;
    dragging = true;
    el.style.cursor = 'grabbing';
    // colocar en top-level para que est√© sobre los dem√°s al arrastrar
    el.style.zIndex = 9999;
  }

  function onMove(clientX, clientY){
    if (!dragging) return;
    const rectField = field.getBoundingClientRect();
    let x = clientX - rectField.left - offsetX;
    let y = clientY - rectField.top - offsetY;
    x = Math.max(0, Math.min(field.clientWidth - el.clientWidth, x));
    y = Math.max(0, Math.min(field.clientHeight - el.clientHeight, y));
    el.style.left = `${Math.round(x)}px`;
    el.style.top = `${Math.round(y)}px`;
  }

  function endDrag(){
    if (!dragging) return;
    dragging = false;
    el.style.cursor = 'grab';
    el.style.zIndex = '';

    // Snap vertical: encontrar closest en positionsY
    const currentTop = parseFloat(el.style.top);
    const values = Object.values(positionsY);
    let closest = values[0];
    let minDist = Math.abs(values[0] - currentTop);
    for (let v of values) {
      const d = Math.abs(v - currentTop);
      if (d < minDist) { minDist = d; closest = v; minDist = d; }
    }
    el.style.top = `${closest}px`;

    // Reordenar horizontalmente los elementos que comparten la misma top (misma l√≠nea)
    const linePlayers = Array.from(field.querySelectorAll('.player-card')).filter(p => Math.abs(parseFloat(p.style.top) - closest) < 1);
    linePlayers.sort((a, b) => parseFloat(a.style.left) - parseFloat(b.style.left));
    const spacing = field.clientWidth / (linePlayers.length + 1);
    linePlayers.forEach((p, idx) => {
      p.style.left = `${Math.round(spacing * (idx + 1) - 20)}px`;
    });
  }

  // Eventos rat√≥n
  el.addEventListener('mousedown', e => { e.preventDefault(); startDrag(e.clientX, e.clientY); document.addEventListener('mousemove', mouseMove); document.addEventListener('mouseup', mouseUp); });
  function mouseMove(e){ onMove(e.clientX, e.clientY); }
  function mouseUp(){ document.removeEventListener('mousemove', mouseMove); document.removeEventListener('mouseup', mouseUp); endDrag(); }

  // Eventos t√°ctiles
  el.addEventListener('touchstart', e => {
    const t = e.touches[0];
    startDrag(t.clientX, t.clientY);
  }, { passive: true });
  el.addEventListener('touchmove', e => {
    e.preventDefault(); // evitar scroll del contenedor al arrastrar
    const t = e.touches[0];
    onMove(t.clientX, t.clientY);
  }, { passive: false });
  el.addEventListener('touchend', e => { endDrag(); }, { passive: true });

  // Cursor por defecto
  el.style.cursor = 'grab';
}

/* =========================
   EXPORTAR CAMPO / AMBOS
   ========================= */

/* Exporta un campo concreto (forzando fondo y alpha) */
async function exportField(fieldId) {
  const field = document.getElementById(fieldId);
  if (!field) return alert("No se encontr√≥ el campo.");

  // Esperar dos frames para asegurar render completo
  await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)) );

  // Forzar estilos temporales que mejoran captura (se vuelven a pintar despu√©s)
  const prev = { opacity: field.style.opacity, mixBlendMode: field.style.mixBlendMode, filter: field.style.filter, backgroundColor: field.style.backgroundColor };
  field.style.opacity = "1";
  field.style.mixBlendMode = "normal";
  field.style.filter = "none";
  field.style.backgroundColor = "#0f4720";

  // Captura con html2canvas (config similar al original)
  const canvas = await html2canvas(field, {
    backgroundColor: "#0f4720",
    scale: 2,
    useCORS: true,
    logging: false,
    removeContainer: true,
    allowTaint: true,
    willReadFrequently: true
  });

  // Forzar canal alpha a 255 (evita transparencia)
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  for (let i = 3; i < imgData.data.length; i += 4) imgData.data[i] = 255;
  ctx.putImageData(imgData, 0, 0);

  // Restaurar estilos
  field.style.opacity = prev.opacity || '';
  field.style.mixBlendMode = prev.mixBlendMode || '';
  field.style.filter = prev.filter || '';
  field.style.backgroundColor = prev.backgroundColor || '';

  // Descargar imagen
  const link = document.createElement("a");
  link.download = `${fieldId}.png`;
  link.href = canvas.toDataURL("image/png", 1.0);
  link.click();
}

/* Exporta ambos campos en una sola imagen (combinada) */
async function exportarAmbosAlineaciones() {
  const field1 = document.getElementById("field1");
  const field2 = document.getElementById("field2");
  if (!field1 || !field2) return alert("No se encontraron los campos.");

  const titulo = prompt("Introduce el t√≠tulo para la imagen:", "‚öΩ Partido ‚öΩ");

  // Esperar 2 frames
  await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  const opts = { backgroundColor: "#0f4720", scale: 2, useCORS: true, logging: false, allowTaint: true, willReadFrequently: true };
  const [canvas1, canvas2] = await Promise.all([ html2canvas(field1, opts), html2canvas(field2, opts) ]);

  const spacing = 40;
  const padding = 40;
  const topMargin = 60;
  const bottomMargin = 40;
  const totalWidth = canvas1.width + canvas2.width + spacing + padding * 2;
  const totalHeight = Math.max(canvas1.height, canvas2.height) + topMargin + bottomMargin;

  const combinedCanvas = document.createElement("canvas");
  combinedCanvas.width = totalWidth;
  combinedCanvas.height = totalHeight;
  const ctx = combinedCanvas.getContext("2d", { willReadFrequently: true });

  // Fondo claro (igual que tu versi√≥n original)
  ctx.fillStyle = "#d9d9d9";
  ctx.fillRect(0, 0, totalWidth, totalHeight);

  // T√≠tulo
  ctx.fillStyle = "#222";
  ctx.font = "bold 28px Arial";
  ctx.textAlign = "center";
  ctx.fillText(titulo || "‚öΩ Partido ‚öΩ", totalWidth / 2, 40);

  const yOffset = topMargin;
  const x1 = padding;
  const x2 = padding + canvas1.width + spacing;

  ctx.drawImage(canvas1, x1, yOffset);
  ctx.drawImage(canvas2, x2, yOffset);

  // Forzar alpha a 1
  const imgData = ctx.getImageData(0, 0, combinedCanvas.width, combinedCanvas.height);
  for (let i = 3; i < imgData.data.length; i += 4) imgData.data[i] = 255;
  ctx.putImageData(imgData, 0, 0);

  const link = document.createElement("a");
  link.download = "alineaciones_whatsapp.png";
  link.href = combinedCanvas.toDataURL("image/png", 1.0);
  link.click();
}

/* Asociar bot√≥n exportar ambos */
document.getElementById('exportarAmbosBtn').addEventListener('click', exportarAmbosAlineaciones);

/* =========================
   FIN DE SCRIPT
   ========================= */
</script>
</body>
</html>
