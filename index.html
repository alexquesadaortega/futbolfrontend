<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Generador de Equipos</title>

<!-- ICONO Y COLOR DE LA WEB APP -->
<link rel="icon" href="icono.png" type="image/png">
<link rel="apple-touch-icon" href="icono.png">
<meta name="theme-color" content="#0f1724">
<link rel="manifest" href="manifest.json">

<style>
/* ----------------- TIPOGRAFÍA Y FONDO ----------------- */
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

:root{ --bg1:#0f1724; --bg2:#1a2238; --accent:#06b6d4; --card-bg: rgba(255,255,255,0.05); --text:#e6eef6; }

body{
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
  color: var(--text);
  padding: 10px;
  text-align: center;
  margin: 0;
  min-height: 100vh;
  animation: fadeIn 0.8s ease-in-out;
}

/* Animaciones reutilizables */
@keyframes fadeIn{ from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:none;} }
@keyframes slideDown{ from{transform:translateY(-20px);opacity:0;} to{transform:none;opacity:1;} }
@keyframes fadeInUp{ from{opacity:0; transform:translateY(6px);} to{opacity:1; transform:none;} }

/* ----------------- ENCABEZADO ----------------- */
h1{
  margin-bottom:10px;
  font-weight:600;
  color:#0ff0fc;
  letter-spacing:0.5px;
  text-shadow:0 0 8px rgba(0,255,255,0.4);
  animation: slideDown 0.8s ease;
}

/* ----------------- TARJETAS / COMPONENTES ----------------- */
.card{
  background: var(--card-bg);
  backdrop-filter: blur(8px);
  padding: 14px;
  border-radius: 12px;
  margin: 10px auto;
  width: 95%;
  max-width: 600px;
  text-align: left;
  box-shadow: 0 0 12px rgba(0,0,0,0.3);
  animation: fadeIn 1s ease;
}

/* Lista de jugadores */
.players-list { list-style:none; padding:0; max-height:200px; overflow:auto; }
.players-list li{
  padding:6px; margin:3px 0; background: rgba(255,255,255,0.08); border-radius:8px;
  display:flex; justify-content:space-between; transition: background 0.2s, transform 0.2s;
  animation: fadeInUp 0.4s ease both;
}
.players-list li:hover{ background: rgba(255,255,255,0.15); transform: translateX(4px); }

/* Botones */
button{
  background: linear-gradient(135deg,#06b6d4,#0ea5e9);
  color:#fff; cursor:pointer; margin:6px; padding:8px 14px; border-radius:8px;
  border:none; font-weight:600; font-size:14px; transition: all 0.2s ease; animation: fadeIn 0.8s ease;
}
button:hover{ transform: scale(1.05); box-shadow:0 0 10px rgba(6,182,212,0.5);}
button:active{ transform: scale(0.96); }

/* Proposals grid */
#proposalsContainer{ margin-top:12px; display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:14px; }
.proposal{
  padding:10px; background: rgba(255,255,255,0.05); border-radius:10px; cursor:pointer;
  display:flex; flex-direction:column; gap:6px; transition: transform 0.2s, background 0.2s; animation: fadeInUp 0.6s ease both;
}
.proposal:hover{ transform: translateY(-4px); background: rgba(255,255,255,0.1); }

.team-box{
  background: rgba(255,255,255,0.03); padding:6px; border-radius:8px; display:flex; flex-direction:column; gap:3px;
}
.team-title{ font-weight:600; margin-bottom:4px; color: var(--accent); }
.player-entry{ display:flex; justify-content:space-between; background: rgba(255,255,255,0.08); padding:4px 8px; border-radius:6px; font-size:13px; }

/* ----------------- CAMPOS ----------------- */
#fieldsContainer{ display:flex; justify-content:center; gap:20px; margin-top:25px; flex-wrap:wrap; animation: fadeIn 1s ease; }

.field{
  position: relative; width: 320px; height: 480px; background-color: #0f4720; border:2px solid #fff;
  border-radius:10px; display:none; box-shadow:0 0 20px rgba(0,255,100,0.15); overflow:hidden;
}
.field-title{
  position:absolute; top:6px; width:100%; text-align:center; font-weight:600; color:#fff; font-size:13px; letter-spacing:0.5px;
  text-shadow:0 0 6px rgba(0,0,0,0.5);
}

  /*Boton Enviar equipos*/
  <div id="exportSection" style="text-align:center; margin-top:12px; display:none;">
  <button id="exportTeamsBtn">Enviar equipos</button>
</div>

/* Player cards para html2canvas — fondo sólido para evitar transparencia */
.player-card{
  position:absolute; width:45px; height:50px; text-align:center; font-weight:600; color:#fff; cursor:grab;
  transition: transform 0.2s ease; animation: fadeInUp 0.3s ease both; background:#000; border-radius:5px; overflow:hidden;
}
.player-card img{ width:100%; height:100%; display:block; background:#000; }
.player-card span{ display:block; font-size:10px; margin-top:2px; word-wrap:break-word; background:#000; color:#fff; padding:1px 2px; border-radius:2px; }

/* Login / register estilos */
.login-card, #registerCard{ max-width:300px; margin:20px auto; padding:20px; background:var(--card-bg); border-radius:10px; text-align:center; box-shadow:0 0 12px rgba(0,0,0,0.3); }
.login-input, #registerCard input{ width:90%; margin:6px 0; padding:8px; border-radius:8px; border:none; background: rgba(255,255,255,0.1); color:#e6eef6; font-size:14px; }
.login-input::placeholder, #registerCard input::placeholder{ color:#b8c2cc; }

/* Mobile PWA display-mode adjustments */
@media (display-mode: standalone){
  body{ padding:0; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; overflow:hidden; }
  h1{ margin-top:20px; font-size:22px; }
  .card{ width:90%; margin-top:10px; }
  button{ font-size:16px; padding:12px 18px; border-radius:10px; }
  #fieldsContainer{ transform: scale(0.9); }
}

/* --- Mejora de nitidez en exportación (forzar comportamiento) --- */
.player-card, .player-card img, .player-card span{ opacity:1 !important; filter:none !important; transform:none !important; mix-blend-mode:normal !important; will-change:auto !important; isolation:isolate !important; }
#field1, #field2{ background-color:#0f4720 !important; opacity:1 !important; mix-blend-mode:normal !important; transform:none !important; will-change:auto !important; isolation:isolate !important; }

/* --- Campo (líneas internas / áreas) visuales internas (si se necesitan) --- */
.player{ position:absolute; text-align:center; color:white; font-size:12px; user-select:none; }
.shirt{ border-radius:50%; width:28px; height:28px; line-height:28px; font-weight:bold; margin:auto; box-shadow:0 0 4px rgba(0,0,0,0.4); }
.shirt.black{ background:black; color:white; }
.shirt.white{ background:white; color:black; }
.player-name{ font-size:10px; color:white; text-shadow:0 0 3px black; }

</style>
</head>
<body>

<h1>GENERADOR DE EQUIPOS Y ALINEACIONES</h1>

<!-- LOGIN -->
<div class="login-card" id="loginCard">
  <strong>Identifícate</strong><br>
  <input type="text" id="loginUser" placeholder="Usuario" class="login-input"><br>
  <input type="password" id="loginPass" placeholder="Contraseña" class="login-input"><br>
  <button id="loginBtn">Entrar</button>
  <div id="loginMsg" style="color:red;margin-top:6px;"></div>
</div>

<!-- REGISTRO -->
<div id="registerCard">
  <strong>Regístrate</strong><br>
  <input type="text" id="regUser" placeholder="Usuario"><br>
  <input type="password" id="regPass" placeholder="Contraseña"><br>
  <button id="registerBtn">Registrar</button>
  <div id="regMsg" style="color:red;margin-top:6px;"></div>
</div>

<!-- JUGADORES -->
<div class="card" id="playersCard" style="display:none;">
  <strong>Selecciona los jugadores que van a jugar (máx. 14):</strong>
  <ul id="playersContainer" class="players-list"></ul>
  <button id="generate">Generar hasta 5 combinaciones</button>
  <button id="generateOptimized">Optimizar equilibrio</button>
</div>

<div class="card" id="addPlayerCard" style="display:none;">
  <strong>Agregar jugador:</strong><br>
  <input type="text" id="newName" placeholder="Nombre" class="login-input"><br>
  <select id="newPos" class="login-input">
    <option value="Portero">Portero</option>
    <option value="Defensa">Defensa</option>
    <option value="Delantero">Delantero</option>
    <option value="Mediocentro">Mediocentro</option>
  </select><br>
  <input type="number" id="newMedia" placeholder="Media (0-10)" class="login-input" min="0" max="10"><br>
  <button id="addPlayerBtn">Agregar jugador</button>
</div>

<!-- PROPUESTAS -->
<div class="card" id="proposalsCard" style="display:none;">
  <strong>Propuestas generadas (haz click en la que prefieras):</strong>
  <div id="proposalsContainer"></div>
</div>

<!-- CAMPOS -->
<div id="fieldsContainer">
  <div>
    <div id="field1" class="field"><div class="field-title">Equipo Negro</div></div>
  </div>
  <div>
    <div id="field2" class="field"><div class="field-title">Equipo Blanco</div></div>
  </div>
</div>

<!-- Librería html2canvas -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>
/* =========================
   VARIABLES GLOBALES / CONFIG
   ========================= */

/* URL a tu backend (igual que tenías) */
const API_URL = 'https://futbol-backend-0gnv.onrender.com';

/* Orden de posiciones para mostrar en la lista */
const positionOrder = { Portero: 0, Defensa: 1, Delantero: 2, Mediocentro: 3 };

/* Imágenes de camisetas (las rutas que usas) */
const shirtImages = { black: "camiseta-negra.png", white: "camiseta-blanca.png" };

/* Estado global que usábamos */
let currentUser = null;
let currentPlayers = [];
let currentProposals = [];
let teamAlertShown = false; // evita múltiples alertas repetidas

/* =========================
   LOGIN / REGISTRO
   ========================= */

/* Login: POST /login, luego cargar jugadores con POST /get-players */
document.getElementById('loginBtn').addEventListener('click', async () => {
  const username = document.getElementById('loginUser').value.trim();
  const password = document.getElementById('loginPass').value.trim();
  const loginMsg = document.getElementById('loginMsg'); 
  loginMsg.textContent = '';

  if (!username || !password) {
    loginMsg.textContent = 'Introduce usuario y contraseña';
    return;
  }

  try {
    const res = await fetch(`${API_URL}/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });
    const data = await res.json();

    if (!data.success) {
      loginMsg.textContent = data.message || 'Credenciales incorrectas';
      return;
    }

    currentUser = { username };

    // Intentar cargar jugadores desde backend; si falla inicializamos array vacío
    try {
      const resPlayers = await fetch(`${API_URL}/get-players`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username })
      });
      const playersResp = await resPlayers.json();
      currentPlayers = Array.isArray(playersResp.players) ? playersResp.players : [];
    } catch (err) {
      console.warn('No se pudieron cargar los jugadores del servidor, inicializando vacío', err);
      currentPlayers = [];
    }

    // Mostrar UI principal
    document.getElementById('loginCard').style.display = 'none';
    document.getElementById('registerCard').style.display = 'none';
    document.getElementById('playersCard').style.display = 'block';
    document.getElementById('addPlayerCard').style.display = 'block';
    renderPlayerList();

  } catch (err) {
    console.error(err);
    loginMsg.textContent = 'Error de conexión';
  }
});

/* Registro: POST /register */
document.getElementById('registerBtn').addEventListener('click', async ()=> {
  const username = document.getElementById('regUser').value.trim();
  const password = document.getElementById('regPass').value.trim();
  const regMsg = document.getElementById('regMsg');
  regMsg.textContent = '';

  if (!username || !password) { regMsg.textContent = 'Introduce usuario y contraseña'; return; }

  try{
    const res = await fetch(`${API_URL}/register`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ username, password })
    });
    const data = await res.json();
    regMsg.textContent = data.message || '';
    if (data.success) {
      document.getElementById('regUser').value = '';
      document.getElementById('regPass').value = '';
    }
  } catch (err) {
    console.error(err);
    regMsg.textContent = 'Error de conexión';
  }
});

/* =========================
   RENDER LISTA DE JUGADORES
   ========================= */

/* Renderiza la lista local de jugadores con checkbox y botón eliminar */
function renderPlayerList() {
  // Ordenamos por posición según positionOrder pero mantenemos index original
  const mapped = currentPlayers.map((p, idx) => ({ p, idx }));
  mapped.sort((a,b) => (positionOrder[a.p.pos] ?? 99) - (positionOrder[b.p.pos] ?? 99));

  const container = document.getElementById('playersContainer');
  container.innerHTML = '';

  mapped.forEach(({ p, idx }) => {
    const li = document.createElement('li');
    li.innerHTML = `
      <label style="flex:1;">
        <input type="checkbox" data-index="${idx}">
        ${p.name} (${p.pos}) [${p.media}]
      </label>
      <button class="delete-btn" data-index="${idx}" style="margin-left:8px; background-color:#e74c3c; color:white; border:none; border-radius:5px; padding:4px 8px; cursor:pointer;">
        Eliminar
      </button>
    `;
    container.appendChild(li);
  });

  // Limitar selección a 14 checkboxes marcados
  const checkboxes = container.querySelectorAll('input[type="checkbox"]');
  checkboxes.forEach(cb => {
    cb.addEventListener('change', () => {
      const checked = container.querySelectorAll('input[type="checkbox"]:checked');
      if (checked.length > 14) {
        cb.checked = false;
        alert('No se pueden seleccionar más de 14 jugadores');
      }
    });
  });

  // Asociar evento de eliminar a cada botón
  container.querySelectorAll('.delete-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const idx = Number(btn.dataset.index);
      const player = currentPlayers[idx];
      if (!player) return;
      if (!confirm(`¿Seguro que quieres eliminar a ${player.name}?`)) return;

      try {
        const res = await fetch(`${API_URL}/delete-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username: currentUser.username, playerName: player.name })
        });
        const data = await res.json();
        if (!data.success) { alert(data.message || 'Error al eliminar jugador'); return; }

        // Eliminar localmente y re-renderizar
        currentPlayers.splice(idx, 1);
        renderPlayerList();
      } catch (err) {
        console.error('Error al eliminar jugador:', err);
        alert('Error de conexión al eliminar jugador');
      }
    });
  });
}

/* =========================
   AGREGAR JUGADOR
   ========================= */
document.getElementById('addPlayerBtn').addEventListener('click', async ()=> {
  const name = document.getElementById('newName').value.trim();
  const pos = document.getElementById('newPos').value;
  const media = parseFloat(document.getElementById('newMedia').value);
  if (!name || isNaN(media) || media < 0 || media > 10) { alert('Datos incorrectos'); return; }

  const newPlayer = { name, pos, media };
  try {
    const res = await fetch(`${API_URL}/add-player`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ username: currentUser.username, player: newPlayer })
    });
    const data = await res.json();
    if (!data.success) { alert(data.message || 'Error al guardar jugador'); return; }
    currentPlayers.push(newPlayer);
    renderPlayerList();
    document.getElementById('newName').value = '';
    document.getElementById('newMedia').value = '';
  } catch (err) {
    console.error(err);
    alert('Error al guardar jugador');
  }
});

/* =========================
   FUNCIONES PARA GENERAR EQUIPOS
   ========================= */

/* Mezcla Fisher-Yates (in-place) */
function shuffle(a){
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* Calcula media de 'media' de jugadores en un equipo */
function averageMedia(team){
  return team.reduce((s, p) => s + (p.media || 0), 0) / (team.length || 1);
}

/* Comprueba si una propuesta ya está en la lista (por nombres) */
function isDuplicate(proposals, newTeams){
  const newStr = JSON.stringify(newTeams.map(t => t.map(p => p.name).sort()));
  return proposals.some(p => JSON.stringify(p.map(t => t.map(p2 => p2.name).sort())) === newStr);
}

/* Genera dos equipos balanceados intentando respetar mínimos por posición.
   Mantener la lógica y límites parecidos a la versión original.
*/
function generateTeams(players, numTeams = 2) {
  const maxPlayers = 7;

  // Agrupar por posiciones conocidas
  const posGroups = { Portero: [], Defensa: [], Delantero: [], Otros: [] };
  players.forEach(p => {
    if (p.pos === 'Portero' || p.pos === 'Defensa' || p.pos === 'Delantero' || p.pos === 'Mediocentro') {
      posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos] = posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos] || [];
      posGroups[p.pos === 'Mediocentro' ? 'Mediocentro' : p.pos].push(p);
    } else {
      posGroups.Otros.push(p);
    }
  });

  // Validación mínima (igual que tu lógica original)
  const minPorteros = (posGroups.Portero?.length || 0);
  const minDefensas = (posGroups.Defensa?.length || 0);
  const minDelanteros = (posGroups.Delantero?.length || 0);
  if (minPorteros < 2 || minDefensas < 6 || minDelanteros < 2) {
    if (!teamAlertShown) { alert('No hay suficientes jugadores para formar equipos completos respetando mínimos por posición'); teamAlertShown = true; }
    return null;
  }

  let bestTeams = null;
  let smallestDiff = Infinity;
  const iterations = 500;

  for (let it = 0; it < iterations; it++) {
    // Copias locales
    const porteros = [...(posGroups.Portero || [])];
    const defensas = [...(posGroups.Defensa || [])];
    const delanteros = [...(posGroups.Delantero || [])];
    const mediocentros = [...(posGroups.Mediocentro || [])];
    const otros = [...(posGroups.Otros || [])];

    shuffle(porteros); shuffle(defensas); shuffle(delanteros); shuffle(mediocentros); shuffle(otros);

    let teamA = [], teamB = [];

    // Asignar porteros
    if (porteros.length >= 2) { teamA.push(porteros.shift()); teamB.push(porteros.shift()); }

    // Asignar defensas: 3 y 3
    teamA.push(...defensas.splice(0, 3));
    teamB.push(...defensas.splice(0, 3));

    // Asignar delanteros: 1 y 1
    if (delanteros.length >= 2) { teamA.push(delanteros.shift()); teamB.push(delanteros.shift()); }

    // Si hay mediocentros, repartir uno por equipo si es posible
    if (mediocentros.length > 0) {
      teamA.push(mediocentros.shift());
      if (mediocentros.length > 0) teamB.push(mediocentros.shift());
    }

    // Rellenar con los restantes (porteros/defensas/delanteros/otros) hasta maxPlayers
    const remaining = [...porteros, ...defensas, ...delanteros, ...mediocentros, ...otros];
    while (teamA.length < maxPlayers && remaining.length > 0) teamA.push(remaining.shift());
    while (teamB.length < maxPlayers && remaining.length > 0) teamB.push(remaining.shift());

    // Validar tamaño
    if (teamA.length !== maxPlayers || teamB.length !== maxPlayers) continue;

    const diff = Math.abs(averageMedia(teamA) - averageMedia(teamB));
    if (diff < smallestDiff) {
      smallestDiff = diff;
      bestTeams = [teamA, teamB];
    }
  }

  if (!bestTeams) {
    if (!teamAlertShown) { alert('No se pudieron generar equipos completos con los jugadores seleccionados'); teamAlertShown = true; }
    return null;
  }
  return bestTeams;
}

/* =========================
   GENERAR PROPUESTAS (interfaz)
   ========================= */

function generateProposals(selected, optimized = false) {
  teamAlertShown = false;
  currentProposals = [];
  let attempts = 0;
  while (currentProposals.length < 5 && attempts < 50) {
    const teams = generateTeams(selected, 2);
    if (!teams) { attempts++; continue; }
    if (!isDuplicate(currentProposals, teams)) currentProposals.push(teams);
    attempts++;
  }
  if (currentProposals.length === 0) {
    console.warn('No se pudieron generar equipos válidos con los jugadores seleccionados');
    return;
  }
  renderProposals();
}

/* Botón generar normal */
document.getElementById('generate').addEventListener('click', () => {
  const selectedIndexes = [...document.querySelectorAll('#playersContainer input:checked')].map(chk => Number(chk.dataset.index));
  if (selectedIndexes.length < 5) { alert('Selecciona al menos 5 jugadores'); return; }
  const selected = selectedIndexes.map(i => currentPlayers[i]).filter(Boolean);
  const count = { Portero:0, Defensa:0, Delantero:0 };
  selected.forEach(p => count[p.pos] = (count[p.pos]||0) + 1);
  if (count.Portero < 1 || count.Defensa < 3 || count.Delantero < 1) {
    alert('Debe haber al menos 1 portero, 3 defensas y 1 delantero seleccionados'); return;
  }
  generateProposals(selected);
});

/* Botón generar optimizado (misma interfase pero con marca 'optimized' si quisieras ampliar) */
document.getElementById('generateOptimized').addEventListener('click', () => {
  const selectedIndexes = [...document.querySelectorAll('#playersContainer input:checked')].map(chk => Number(chk.dataset.index));
  if (selectedIndexes.length < 5) { alert('Selecciona al menos 5 jugadores'); return; }
  const selected = selectedIndexes.map(i => currentPlayers[i]).filter(Boolean);
  generateProposals(selected, true);
});

/* =========================
   RENDER PROPUESTAS EN PANTALLA
   ========================= */
function renderProposals(){
  const container = document.getElementById('proposalsContainer');
  container.innerHTML = '';
  currentProposals.forEach((teams, i) => {
    const div = document.createElement('div');
    div.className = 'proposal';

    const media1 = averageMedia(teams[0]);
    const media2 = averageMedia(teams[1]);
    const diff = Math.abs(media1 - media2).toFixed(2);

    const diffDiv = document.createElement('div');
    diffDiv.textContent = `Diferencia de media: ${diff}`;
    diffDiv.style.fontSize = '12px';
    diffDiv.style.color = '#aaa';
    div.appendChild(diffDiv);

    ['Equipo Negro','Equipo Blanco'].forEach((title, idx) => {
      const teamDiv = document.createElement('div');
      teamDiv.className = 'team-box';
      const tTitle = document.createElement('div');
      tTitle.className = 'team-title';
      tTitle.textContent = title;
      teamDiv.appendChild(tTitle);

      teams[idx].forEach(p => {
        const pDiv = document.createElement('div');
        pDiv.className = 'player-entry';
        pDiv.textContent = `${p.name} (${p.pos}) [${p.media}]`;
        teamDiv.appendChild(pDiv);
      });
      div.appendChild(teamDiv);
    });

    div.addEventListener('click', () => applyTeams(teams));
    container.appendChild(div);
  });
  document.getElementById('proposalsCard').style.display = 'block';
}

/* =========================
   MOSTRAR / APLICAR EQUIPOS EN LOS CAMPOS
   ========================= */

/* Aplica los equipos seleccionados a los dos campos (muestra campos y dibuja) */
function applyTeams(teams) {
  const field1 = document.getElementById('field1');
  const field2 = document.getElementById('field2');
  field1.style.display = 'block';
  field2.style.display = 'block';

  // Limpiar contenido previo dejando el título
  field1.innerHTML = '<div class="field-title">Equipo Negro</div>';
  field2.innerHTML = '<div class="field-title">Equipo Blanco</div>';

  // Dibujar líneas del campo (visuales internas) y jugadores
  drawField(field1);
  drawField(field2);

  // Dibujar jugadores en cada campo como player-cards (color y comportamiento igual a original)
  drawTeamOnField(field1, teams[0], 'black');
  drawTeamOnField(field2, teams[1], 'white');
}

/* Dibuja las líneas y elementos básicos del campo dentro del elemento field */
function drawField(field){
  // No tocar estilos principales, solo añadir las líneas internas (mejor compatibilidad que canvas)
  // Si existen líneas previas, eliminarlas
  const existing = field.querySelector('.field-lines');
  if (existing) existing.remove();

  const lines = document.createElement('div');
  lines.className = 'field-lines';
  lines.style.position = 'absolute';
  lines.style.left = '0';
  lines.style.top = '0';
  lines.style.width = '100%';
  lines.style.height = '100%';
  lines.style.pointerEvents = 'none'; // para que no interfiera con drag

  // Línea central, áreas y círculo central (usando % para adaptar a distintos tamaños)
  lines.innerHTML = `
    <div style="position:absolute;top:50%;left:0;width:100%;height:2px;background:white;transform:translateY(-50%);"></div>
    <div style="position:absolute;top:0;left:50%;width:30%;height:20%;border:2px solid white;transform:translateX(-50%);box-sizing:border-box;"></div>
    <div style="position:absolute;bottom:0;left:50%;width:30%;height:20%;border:2px solid white;transform:translateX(-50%);box-sizing:border-box;"></div>
    <div style="position:absolute;top:50%;left:50%;width:25%;height:25%;border:2px solid white;border-radius:50%;transform:translate(-50%,-50%);box-sizing:border-box;"></div>
  `;
  field.appendChild(lines);
}
  // Mostrar botón de exportación
document.getElementById('exportSection').style.display = 'block';


/* =========================
   DIBUJAR JUGADORES EN EL CAMPO + DRAG & SNAP
   ========================= */

/* Dibuja un equipo en el campo: crea .player-card, sitúa y hace draggable */
function drawTeamOnField(field, team, color) {
  // Eliminar player-cards previas
  field.querySelectorAll('.player-card').forEach(n => n.remove());

  // Posiciones base en px relative al tamaño del field — se adaptan automáticamente cuando se calcula left/top
  const fw = field.clientWidth;
  const fh = field.clientHeight;

  // Distribución por roles: porteros arriba/abajo o en posiciones típicas dependiendo del equipo
  const positionsY = { Portero: fh * 0.85, Defensa: fh * 0.62, Mediocentro: fh * 0.45, Delantero: fh * 0.28 };

  // Separar mediocentro si existe (igual que lógica original pero más explícita)
  const mediocentro = team.find(p => p.pos === 'Mediocentro') || null;

  // Categorías a iterar (con 'Otros' para posiciones raras)
  ['Portero','Defensa','Mediocentro','Delantero','Otros'].forEach(cat => {
    let arr;
    if (cat === 'Otros') {
      arr = team.filter(p => !['Portero','Defensa','Delantero','Mediocentro'].includes(p.pos));
    } else {
      arr = team.filter(p => p.pos === cat);
    }
    // Si hay mediocentro, evitar duplicarlo fuera de su categoría
    if (mediocentro && cat !== 'Mediocentro') arr = arr.filter(p => p !== mediocentro);

    // Calcular espaciado horizontal
    const spacing = fw / (arr.length + 1);
    arr.forEach((p, i) => {
      const div = document.createElement('div');
      div.className = 'player-card';
      // Imagen de camiseta + nombre (mantener misma estructura que usabas)
      const img = document.createElement('img'); img.src = shirtImages[color]; img.alt = `${p.name}`;
      const span = document.createElement('span'); span.textContent = p.name;
      div.appendChild(img); div.appendChild(span);

      // Calcular posición: top según rol o mediocentro, left según espaciado
      const y = (p === mediocentro) ? positionsY.Mediocentro : (positionsY[p.pos] || positionsY.Defensa);
      const leftPx = Math.max(5, Math.round(spacing * (i + 1) - 20)); // -20 para centrar
      div.style.top = `${Math.round(y)}px`;
      div.style.left = `${leftPx}px`;

      // Añadir al DOM del campo
      field.appendChild(div);

      // Hacer draggable con snap y reordenado horizontal al soltar
      makeDraggable(div, field, positionsY);
    });
  });
}

/* makeDraggable: permite arrastrar con ratón y táctil, aplica 'snap' vertical a posicionesY y reordena horizontal */
function makeDraggable(el, field, positionsY){
  let offsetX = 0, offsetY = 0;
  let dragging = false;

  // obtener bounding rect del field cada vez (responde a cambios de tamaño)
  function startDrag(clientX, clientY){
    const rect = el.getBoundingClientRect();
    offsetX = clientX - rect.left;
    offsetY = clientY - rect.top;
    dragging = true;
    el.style.cursor = 'grabbing';
    // colocar en top-level para que esté sobre los demás al arrastrar
    el.style.zIndex = 9999;
  }

  function onMove(clientX, clientY){
    if (!dragging) return;
    const rectField = field.getBoundingClientRect();
    let x = clientX - rectField.left - offsetX;
    let y = clientY - rectField.top - offsetY;
    x = Math.max(0, Math.min(field.clientWidth - el.clientWidth, x));
    y = Math.max(0, Math.min(field.clientHeight - el.clientHeight, y));
    el.style.left = `${Math.round(x)}px`;
    el.style.top = `${Math.round(y)}px`;
  }

  function endDrag(){
    if (!dragging) return;
    dragging = false;
    el.style.cursor = 'grab';
    el.style.zIndex = '';

    // Snap vertical: encontrar closest en positionsY
    const currentTop = parseFloat(el.style.top);
    const values = Object.values(positionsY);
    let closest = values[0];
    let minDist = Math.abs(values[0] - currentTop);
    for (let v of values) {
      const d = Math.abs(v - currentTop);
      if (d < minDist) { minDist = d; closest = v; minDist = d; }
    }
    el.style.top = `${closest}px`;

    // Reordenar horizontalmente los elementos que comparten la misma top (misma línea)
    const linePlayers = Array.from(field.querySelectorAll('.player-card')).filter(p => Math.abs(parseFloat(p.style.top) - closest) < 1);
    linePlayers.sort((a, b) => parseFloat(a.style.left) - parseFloat(b.style.left));
    const spacing = field.clientWidth / (linePlayers.length + 1);
    linePlayers.forEach((p, idx) => {
      p.style.left = `${Math.round(spacing * (idx + 1) - 20)}px`;
    });
  }

  // Eventos ratón
  el.addEventListener('mousedown', e => { e.preventDefault(); startDrag(e.clientX, e.clientY); document.addEventListener('mousemove', mouseMove); document.addEventListener('mouseup', mouseUp); });
  function mouseMove(e){ onMove(e.clientX, e.clientY); }
  function mouseUp(){ document.removeEventListener('mousemove', mouseMove); document.removeEventListener('mouseup', mouseUp); endDrag(); }

  // Eventos táctiles
  el.addEventListener('touchstart', e => {
    const t = e.touches[0];
    startDrag(t.clientX, t.clientY);
  }, { passive: true });
  el.addEventListener('touchmove', e => {
    e.preventDefault(); // evitar scroll del contenedor al arrastrar
    const t = e.touches[0];
    onMove(t.clientX, t.clientY);
  }, { passive: false });
  el.addEventListener('touchend', e => { endDrag(); }, { passive: true });

  // Cursor por defecto
  el.style.cursor = 'grab';
}
// Función para capturar y crear imagen
  document.getElementById('exportTeamsBtn').addEventListener('click', async () => {
  const headerText = prompt('Introduce el encabezado para la imagen:', 'Mis Equipos');
  if (!headerText) return;

  const fieldsContainer = document.getElementById('fieldsContainer');

  // Crear un contenedor temporal para incluir el encabezado
  const tempContainer = document.createElement('div');
  tempContainer.style.background = '#0f1724';
  tempContainer.style.padding = '10px';
  tempContainer.style.display = 'inline-block';
  tempContainer.style.textAlign = 'center';
  tempContainer.style.borderRadius = '12px';
  
  // Encabezado
  const headerDiv = document.createElement('div');
  headerDiv.textContent = headerText;
  headerDiv.style.color = '#fff';
  headerDiv.style.fontWeight = '600';
  headerDiv.style.fontSize = '18px';
  headerDiv.style.marginBottom = '10px';
  tempContainer.appendChild(headerDiv);

  // Clonar los campos para que no se altere la UI
  const cloneFields = fieldsContainer.cloneNode(true);
  cloneFields.style.display = 'flex';
  cloneFields.style.gap = '20px';
  tempContainer.appendChild(cloneFields);

  document.body.appendChild(tempContainer);

  // Capturar con html2canvas
  html2canvas(tempContainer, { backgroundColor: null, scale: 2 }).then(canvas => {
    const link = document.createElement('a');
    link.download = 'equipos.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
    tempContainer.remove(); // eliminar contenedor temporal
  }).catch(err => {
    console.error('Error generando imagen:', err);
    alert('Error generando imagen');
    tempContainer.remove();
  });
});

/* =========================
   FIN DE SCRIPT
   ========================= */
</script>
</body>
</html>
